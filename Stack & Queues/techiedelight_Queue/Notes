# Queue Implementation
@ Array
class Queue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int count;
    
    Queue(int size){
        arr = new int[size];
        capacity = size;
        front = 0;
        rear = -1;
        count = 0;
    }
    
    1. int dequeue() {
          if (isEmpty()) {return;}
          int x = arr[front];
          front = (front + 1)%capacity;
          count--;
          return x;
       }
       
     2. void enqueue (int item_ {
            if (isFull()) {return;}
            rear = (rear+1)%capacity;
            arr[rear] = item;
            count++;
        }
     
     3.  int peek() {
            if (isEmpty()) {return;}
            return arr[front];
          }
      
      4. int size() {return count;}
      
      5. boolean isEmpty() {return (size()==0);}
      
      6. boolean isFull() {return (size()==capacity);}
      
@ Queue Interface
psvm{
    Queue<String> queue = new LinkedList<String>();
    queue.add("A");
    queue.peek();
    queue.remove();
    queue.size();
    queue.isEmpty();
}

@ LinkedList -> Can grow/shrink 
class Node{
    int data;
    Node next;
    
    public Node(int data){
      this.data = data;
      this.next = null;
    }
}

class Queue{
    private static Node rear = null, front = null;
    private static int count = 0;
    
    1. public static int dequeue() {
        if (front == null) {return;}
        Node temp = front;
        front = front.next;
        if (front == null) { rear = null; }
        count -= 1;
        return temp.data;
    }
    
    2. void enqueue(int item) {
          Node node = new Node(item);
          if (front == null) {
              front = node;
              rear = node;
          }else{
              rear.next = node;
              rear = node;
          }
          count += 1;
      }
    
    3. int peek(){
          if (front == null) {return;}
          return front.data;
        }
    
    4. boolean isEmpty() {return rear==null && front==null;}
    
    5. int size() {return count;}
    
# Efficiently print all nodes between two given levels in a binary tree
class Node {
    int key;
    Node left = null, right = null;
    
    Node (int key) {this.key = key;}
}

@ 
class Main {
    1. public static void printNodes(Node root, int start, int end){
            if (root == null) {return;}
            Queue<Node> queue = new ArrayDeque<>();
            queue.add(root);
            Node curr = null;
            int level = 0;
            while (!queue.isEmpty()) {
                level++;
                int size = queue.size();
                while (size-- > 0){
                  curr = queue.poll();
                  if(level >= start && level <= end) {S.o.p(curr.key + " ");}
                  if(curr.left != null) {queue.add(curr.left);}
                  if(curr.right != null) {queue.add(curr.right);}
                }
                if (level >= start && level <= end) {S.o.println();}
           }
      }
      
@
class Main {
    1. public static void printNodes (Node root, int start, int end, int level, Map<Integer, List<Integer>> map){
            if (root == null) {return;}
            if (level>=start && level<=end) {
                map.putIfAbsent(level, new ArrayList<>());
                map.get(level).add(root.key);
            }
            printNodes(root.left, start, end, level+1, map);
            printNodes(root.right, start, end, level+1, map);
       }
       
    2. printNodes (Node root, int start, int end){
            Map<Integer, List<Integer>> map = new HashMap<>();
            printNodes(root, start, end, 1, map);
            for(int i = start; i <= end; i++) {
                if (map.containsKey(i)) {
                    System.out.println("Level " +i+ ": " + map.get(i));
                }
            }
        }
        
        
        
            
            
            
            
