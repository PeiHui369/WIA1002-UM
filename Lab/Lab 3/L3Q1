/**
 An interface that describes the operations of a bag of objects.
 @author Frank M. Carrano
 @author Timothy M. Henry
 @version 4.1
 */
public interface BagInterface<T>
{
    /** Gets the current number of entries in this bag.
     @return  The integer number of entries currently in the bag. */
    public int getCurrentSize();

    /** Sees whether this bag is empty.
     @return  True if the bag is empty, or false if not. */
    public boolean isEmpty();

    /** Adds a new entry to this bag.
     @param newEntry  The object to be added as a new entry.
     @return  True if the addition is successful, or false if not. */
    public boolean add(T newEntry);

    /** Removes one unspecified entry from this bag, if possible.
     @return  Either the removed entry, if the removal.
     was successful, or null. */
    public T remove();

    /** Removes one occurrence of a given entry from this bag.
     @param anEntry  The entry to be removed.
     @return  True if the removal was successful, or false if not. */
    public boolean remove(T anEntry);

    /** Removes all entries from this bag. */
    public void clear();

    /** Counts the number of times a given entry appears in this bag.
     @param anEntry  The entry to be counted.
     @return  The number of times anEntry appears in the bag. */
    public int getFrequencyOf(T anEntry);

    /** Tests whether this bag contains a given entry.
     @param anEntry  The entry to locate.
     @return  True if the bag contains anEntry, or false if not. */
    public boolean contains(T anEntry);

    /** Retrieves all entries that are in this bag.
     @return  A newly allocated array of all the entries in the bag.
     Note: If the bag is empty, the returned array is empty. */
    public T[] toArray();
//	public <T> T[] toArray();  // Alternate
//	public Object[] toArray(); // Alternate

    /** Creates a new bag that combines the contents of this bag
     and anotherBag.
     @param anotherBag  The bag that is to be added.
     @return  A combined bag. */
    //	public BagInterface<T> union(BagInterface<T> anotherBag);

    /** Creates a new bag that contains those objects that occur
     in both this bag and anotherBag.
     @param anotherBag  The bag that is to be compared.
     @return  A combined bag. */
    //	public BagInterface<T> intersection(BagInterface<T> anotherBag);

    /** Creates a new bag of objects that would be left in this bag
     after removing those that also occur in anotherBag.
     @param anotherBag  The bag that is to be removed.
     @return  A combined bag. */
    //	public BagInterface<T> difference(BagInterface<T> anotherBag);

    

} // end BagInterface


//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

public final class ArrayBag<T> implements BagInterface<T> {
    private final T[] bag;
    private int numberOfEntries;
    private boolean initialized;
    private static final int DEFAULT_CAPACITY = 25;
    private static final int MAX_CAPACITY = 10000;

    public ArrayBag() {
        this(25);
    }

    public ArrayBag(int desiredCapacity) {
        this.initialized = false;
        if (desiredCapacity <= 10000) {
            T[] tempBag = new Object[desiredCapacity];
            this.bag = tempBag;
            this.numberOfEntries = 0;
            this.initialized = true;
        } else {
            throw new IllegalStateException("Attempt to create a bag whose capacity exceeds allowed maximum.");
        }
    }

    public boolean add(T newEntry) {
        this.checkInitialization();
        boolean result = true;
        if (this.isArrayFull()) {
            result = false;
        } else {
            this.bag[this.numberOfEntries] = newEntry;
            ++this.numberOfEntries;
        }

        return result;
    }

    public T[] toArray() {
        this.checkInitialization();
        T[] result = new Object[this.numberOfEntries];

        for(int index = 0; index < this.numberOfEntries; ++index) {
            result[index] = this.bag[index];
        }

        return result;
    }

    public boolean isEmpty() {
        return this.numberOfEntries == 0;
    }

    public int getCurrentSize() {
        return this.numberOfEntries;
    }

    public int getFrequencyOf(T anEntry) {
        this.checkInitialization();
        int counter = 0;

        for(int index = 0; index < this.numberOfEntries; ++index) {
            if (anEntry.equals(this.bag[index])) {
                ++counter;
            }
        }

        return counter;
    }

    public boolean contains(T anEntry) {
        this.checkInitialization();
        return this.getIndexOf(anEntry) > -1;
    }

    public void clear() {
        while(!this.isEmpty()) {
            this.remove();
        }

    }

    public T remove() {
        this.checkInitialization();
        T result = this.removeEntry(this.numberOfEntries - 1);
        return result;
    }

    public boolean remove(T anEntry) {
        this.checkInitialization();
        int index = this.getIndexOf(anEntry);
        T result = this.removeEntry(index);
        return anEntry.equals(result);
    }

    private boolean isArrayFull() {
        return this.numberOfEntries >= this.bag.length;
    }

    private int getIndexOf(T anEntry) {
        int where = -1;
        boolean found = false;

        for(int index = 0; !found && index < this.numberOfEntries; ++index) {
            if (anEntry.equals(this.bag[index])) {
                found = true;
                where = index;
            }
        }

        return where;
    }

    private T removeEntry(int givenIndex) {
        T result = null;
        if (!this.isEmpty() && givenIndex >= 0) {
            result = this.bag[givenIndex];
            int lastIndex = this.numberOfEntries - 1;
            this.bag[givenIndex] = this.bag[lastIndex];
            this.bag[lastIndex] = null;
            --this.numberOfEntries;
        }

        return result;
    }

    private void checkInitialization() {
        if (!this.initialized) {
            throw new SecurityException("ArrayBag object is not initialized properly.");
        }
    }
}
